#№ Лабораторная работа №2.



## Структура проекта:
<pre>
    .
    ├── second_laba_python                     # Кодовая база моей лабораторной работы
    │   ├── src/                               # Исходный код
    │   ├── tests/                             # Unit тесты для проверки функциональности
    │   ├── .gitignore                         # файл, игнорируемый git
    │   ├── .pre-commit-config.yaml            # Конфигурация автоматической проверки кодстайла перед коммитом
    │   ├── README.md                          # Описание проекта, структуры и функционала
    │   ├── pyproject.toml                     # Конфигурация проекта (метаданные, зависимости, инструменты)
    │   ├── requirements.txt                   # Список зависимостей проекта
    │   ├── uv.lock                            # Lock-файл зафиксированных версий зависимостей
</pre>

## В папке [src](./src) лежат файлы с реализацией задачи заданной в лабораторной работе:
 <pre>
    .
    ├── src
    │   ├── services/             # Папка с сервисами для работы с консолью
    │   ├── __init__.py
    │   ├── config.py             # Конфигурация логирования (настройка handlers, formatters, loggers)
    │   ├── container.py          # Контейнер зависимостей (Dependency Injection) для управления сервисами
    │   ├── enums.py              # Перечисления: режимы чтения файлов (string/bytes) и отображения (simple/detailed)
    │   ├── main.py               # Точка входа в приложение, CLI-команды (ls, cat, cd, cp, mv, rm, zip, unzip, tar, untar, grep)
    │   ├── errorss.py            # Пользовательские исключения (в настоящее время не используется)
</pre>

## В папке [services](./src/services) лежат файлы с реализацией сервисов для работы с консолью:
 <pre>
    .
    ├── services                   # Папка с реализацией консольных команд
    │   ├── __init__.py
    │   ├── base.py                # Абстрактный базовый класс OSConsoleServiceBase с интерфейсом консольных команд
    │   ├── windows_console.py     # Реализация консольного сервиса (команды ls, cat, cd, cp, mv, rm, zip, unzip, tar, untar, grep)
</pre>

---

## Алгоритм работы программы

### Общий алгоритм работы

1. **Инициализация приложения** (`main.py:main()`):
   - Настраивается система логирования через `logging.config.dictConfig(LOGGING_CONFIG)`
   - Создается экземпляр контейнера зависимостей (`Container`) с сервисом `WindowsConsoleService`
   - Контейнер сохраняется в контексте Typer для доступа к нему из команд

2. **Обработка команды**:
   - Typer парсит аргументы командной строки
   - Вызывается соответствующая команда из `main.py` (ls, cat, cd, cp, mv, rm, zip, unzip, tar, untar, grep)
   - Команда получает контейнер зависимостей из контекста и вызывает соответствующий метод сервиса
   - Сервис (`WindowsConsoleService`) выполняет операцию с файловой системой
   - Результаты выводятся в консоль или обрабатываются ошибки

3. **Архитектурный паттерн**:
   - Используется паттерн Dependency Injection через `Container`
   - Абстракция через базовый класс `OSConsoleServiceBase` позволяет легко добавить реализацию для других ОС
   - Разделение ответственности: `main.py` - CLI интерфейс, `windows_console.py` - бизнес-логика

### Общая стратегия обработки ошибок

1. **Уровень сервиса** (`windows_console.py`):
   - Все методы используют try-except блоки для перехвата `OSError`, `PermissionError`, `FileNotFoundError` и других исключений
   - Ошибки логируются через встроенный логгер с указанием уровня (ERROR, WARNING, DEBUG)
   - Исключения пробрасываются наверх после логирования

2. **Уровень CLI** (`main.py`):
   - Перехватываются `OSError` и его подклассы для отображения пользователю через `typer.echo()`
   - Остальные исключения пробрасываются дальше (для неожиданных ошибок)
   - Некоторые команды имеют дополнительную валидацию (например, `rm` проверяет существование пути и запрашивает подтверждение)

3. **Логирование**:
   - Все операции логируются на уровне DEBUG/INFO
   - Ошибки логируются с полным traceback через `logger.exception()`
   - Логи записываются в файл `shell.log` и выводятся в консоль

---

## Описание файлов и функций

### `enums.py`

**Назначение**: Определяет перечисления для режимов работы программы.

#### `FileReadMode` (Enum)
- **`string`**: Режим чтения файла как текста (UTF-8)
- **`bytes`**: Режим чтения файла как байтов
- Используется в команде `cat` для выбора способа чтения файла

#### `FileDisplayMode` (Enum)
- **`simple`**: Простой режим отображения (только имена файлов/директорий)
- **`detailed`**: Подробный режим отображения (права доступа, размер, дата модификации, тип)
- Используется в команде `ls` для выбора формата вывода

---

### `config.py`

**Назначение**: Конфигурация системы логирования.

**Переменная `LOGGING_CONFIG`**:
- Настройка форматтеров: стандартный формат с временем, уровнем, именем логгера и сообщением
- Два обработчика:
  - `console`: вывод в консоль (уровень DEBUG)
  - `file`: запись в файл `shell.log` с ротацией (макс. 5MB, 5 резервных копий)
- Все логгеры настроены на уровень DEBUG

**Важно**: Логирование настроено глобально, все модули используют эту конфигурацию.

---

### `container.py`

**Назначение**: Контейнер зависимостей для управления сервисами (Dependency Injection).

#### `Container` (dataclass)
- **Поле `console_service`**: Экземпляр сервиса консоли (реализующий `OSConsoleServiceBase`)
- **Использование**: Хранит все зависимости приложения, передается через контекст Typer в команды

**Нюансы**:
- Простой контейнер без автоматической инъекции зависимостей
- Создается вручную в `main.py:main()` с передачей сервиса

---

### `services/base.py`

**Назначение**: Абстрактный базовый класс, определяющий интерфейс всех консольных команд.

#### `OSConsoleServiceBase` (ABC)
Абстрактный класс со следующими методами (все абстрактные, без реализации):

1. **`ls(path, display_mode)`** → `list[str]`
   - Отображение содержимого директории
   - Параметры: путь к директории, режим отображения (simple/detailed)
   - Возвращает список строк с информацией о файлах

2. **`cat(filename, mode)`** → `str | bytes`
   - Чтение и отображение содержимого файла
   - Параметры: путь к файлу, режим чтения (string/bytes)
   - Возвращает содержимое файла

3. **`cd(path)`** → `str`
   - Смена рабочей директории
   - Параметры: путь к директории
   - Возвращает абсолютный путь новой директории
   - Поддерживает специальные пути: `.`, `..`, `~`

4. **`cp(src, dst, recursive)`** → `None`
   - Копирование файла или каталога
   - Параметры: источник, назначение, флаг рекурсивного копирования
   - Вызывает исключения при ошибках

5. **`mv(src, dst)`** → `None`
   - Перемещение/переименование файла или каталога
   - Параметры: источник, назначение

6. **`rm(target, recursive)`** → `None`
   - Удаление файла/каталога
   - Параметры: путь к удаляемому объекту, флаг рекурсивного удаления
   - Запрещено удалять корень и `..`

7. **`zip(path, path_arch)`** → `None`
   - Создание ZIP-архива из каталога
   - Параметры: путь к каталогу-источнику, путь к архиву

8. **`unzip(path_arch, res)`** → `None`
   - Распаковка ZIP-архива
   - Параметры: путь к архиву, папка назначения (опционально)

9. **`tar_dir(path_file, path_arch)`** → `None`
   - Создание TAR.GZ архива из каталога
   - Параметры: путь к каталогу-источнику, путь к архиву

10. **`untar(path_archive_tar_gz, res)`** → `None`
    - Распаковка TAR.GZ архива
    - Параметры: путь к архиву, папка назначения (опционально)

11. **`grep(pattern, path, r, ignore_case)`** → `list[str]`
    - Поиск строк по регулярному выражению в файлах
    - Параметры: регулярное выражение, путь (файл/каталог), флаг рекурсивного поиска, флаг игнорирования регистра
    - Возвращает список строк формата "file:line:text"

**Нюансы**: Все методы абстрактные, реализация обязательна в дочерних классах.

---

### `services/windows_console.py`

**Назначение**: Реализация консольного сервиса для Windows с полной реализацией всех команд.

#### `WindowsConsoleService` (класс)
Наследуется от `OSConsoleServiceBase`, реализует все абстрактные методы.

##### `__init__(logger)` → `None`
- **Параметры**: `logger` - объект логгера для записи операций
- **Назначение**: Инициализация сервиса, сохранение логгера в `self._logger`
- **Нюансы**: Логгер используется во всех методах для записи действий и ошибок

##### `format_detailed(entry)` → `str`
- **Параметры**: `entry` - объект `Path` (файл или директория)
- **Назначение**: Форматирование подробной информации о файле для режима `detailed` в `ls`
- **Алгоритм**:
  1. Получение статистики файла через `entry.stat()`
  2. Извлечение прав доступа через `oct(stat_module.S_IMODE(stat_info.st_mode))`
  3. Формирование строки: `{тип}{права} {размер:>10} {дата} {имя}\n`
- **Обработка ошибок**: При ошибке возвращается строка с дефолтными значениями и логируется предупреждение

##### `ls(path, mode)` → `list[str]`
- **Параметры**: `path` - путь к директории, `mode` - режим отображения
- **Алгоритм**:
  1. Преобразование пути в объект `Path`
  2. Проверка существования и типа (должна быть директорией)
  3. Получение списка элементов через `path.iterdir()`
  4. В зависимости от режима: добавление имен (`simple`) или форматирование через `format_detailed` (`detailed`)
- **Ошибки**: `FileNotFoundError`, `NotADirectoryError` с логированием

##### `cat(path_file, mode)` → `str | bytes`
- **Параметры**: `path_file` - путь к файлу, `mode` - режим чтения
- **Алгоритм**:
  1. Проверка существования файла
  2. Проверка, что путь не является директорией
  3. В зависимости от режима: `path.read_text(encoding="utf-8")` или `path.read_bytes()`
- **Ошибки**: `FileNotFoundError`, `IsADirectoryError`, `OSError` с полным логированием

##### `cd(path)` → `str`
- **Параметры**: `path` - путь к директории
- **Алгоритм**:
  1. Обработка специальных путей: `~` и `~/` преобразуются через `os.path.expanduser()`
  2. Преобразование относительного пути в абсолютный относительно текущей директории
  3. Разрешение пути через `path.resolve()` для обработки `..`
  4. Проверка существования и типа
  5. Смена директории через `os.chdir(path)`
- **Нюансы**:
  - Поддерживается обработка `~`, `.`, `..`
  - Путь всегда разрешается в абсолютный
- **Ошибки**: `FileNotFoundError`, `NotADirectoryError`

##### `cp(path1, path2, recursive)` → `None`
- **Параметры**: `path1` - источник, `path2` - назначение, `recursive` - флаг рекурсивного копирования
- **Алгоритм для директорий** (если `src_path.is_dir()`):
  1. Проверка наличия флага `recursive`
  2. Определение конечного пути: если `dst_path` - существующая директория, то `dst_path/src_path.name`, иначе `dst_path`
  3. Если конечный путь существует:
     - Если это директория: копирование содержимого через `shutil.copytree()` для каждой поддиректории и `shutil.copy2()` для файлов
     - Если это файл: ошибка `FileExistsError`
  4. Если не существует: `shutil.copytree(src_path, final_dst)`
- **Алгоритм для файлов**:
  1. Определение конечного пути (аналогично директориям)
  2. Создание родительских директорий через `mkdir(parents=True, exist_ok=True)`
  3. Копирование через `shutil.copy2()`
- **Нюансы**:
  - При копировании в существующую директорию имя сохраняется
  - Автоматическое создание родительских директорий
  - При копировании директории в существующую директорию содержимое копируется, а не перезаписывается
- **Ошибки**: `FileNotFoundError`, `IsADirectoryError`, `PermissionError`, `OSError`

##### `mv(path1, path2)` → `None`
- **Параметры**: `path1` - источник, `path2` - назначение
- **Алгоритм**:
  1. Определение конечного пути: если `dst_path` - существующая директория, то `dst_path/src_path.name`
  2. Создание родительских директорий через `mkdir(parents=True, exist_ok=True)`
  3. Перемещение через `shutil.move()`
- **Нюансы**: Перемещение работает и как переименование, и как перемещение в директорию
- **Ошибки**: `FileNotFoundError`, `PermissionError`, `OSError`

##### `rm(path_file, r)` → `None`
- **Параметры**: `path_file` - путь к удаляемому объекту, `r` - флаг рекурсивного удаления
- **Алгоритм**:
  1. Проверка защищенных путей: `..`, `/` - запрещены
  2. Разрешение пути через `resolve()`
  3. Проверка, что путь не является корнем диска (`Path(res.anchor)`)
  4. Проверка существования
  5. Если директория: проверка флага `r`, удаление через `shutil.rmtree()` или ошибка
  6. Если файл: удаление через `res.unlink()`
- **Нюансы**:
  - Защита от удаления корня и родительского каталога
  - Требуется явный флаг `-r` для удаления директорий
- **Ошибки**: `PermissionError`, `FileNotFoundError`, `IsADirectoryError`, `OSError`

##### `zip(path, path_arch)` → `None`
- **Параметры**: `path` - путь к каталогу-источнику, `path_arch` - путь к архиву
- **Алгоритм**:
  1. Проверка существования и типа (должен быть директорией)
  2. Создание родительских директорий архива
  3. Открытие ZIP-архива в режиме записи с сжатием `ZIP_DEFLATED`
  4. Рекурсивный обход через `src_dir.rglob("*")` всех файлов
  5. Добавление каждого файла в архив с сохранением относительного пути через `arcname = path.relative_to(src_dir)`
  6. Пропуск директорий (добавляются только файлы)
- **Нюансы**:
  - Используется `zipfile.ZipFile` из стандартной библиотеки
  - Архив создается только из файлов, структура директорий сохраняется через `arcname`
- **Ошибки**: `FileNotFoundError`, `NotADirectoryError`, общие исключения с логированием

##### `unzip(path_arch, res)` → `None`
- **Параметры**: `path_arch` - путь к архиву, `res` - папка назначения (None = текущая директория)
- **Алгоритм**:
  1. Определение папки назначения (текущая директория или `res`)
  2. Проверка существования архива
  3. Создание директории назначения
  4. Открытие ZIP-архива в режиме чтения
  5. Распаковка всех файлов через `zf.extractall(dst_dir)`
- **Нюансы**: Если `res` не указан, используется текущая рабочая директория
- **Ошибки**: `FileNotFoundError`, общие исключения с логированием

##### `tar_dir(path_file, path_arch)` → `None`
- **Параметры**: `path_file` - путь к каталогу-источнику, `path_arch` - путь к архиву
- **Алгоритм**:
  1. Проверка существования и типа (должен быть директорией)
  2. Создание родительских директорий архива
  3. Открытие TAR.GZ архива в режиме `"w:gz"` (запись с gzip сжатием)
  4. Добавление всей директории через `tf.add(src_dir, arcname=src_dir.name)`
- **Нюансы**:
  - Используется `tarfile.open()` из стандартной библиотеки
  - Режим `"w:gz"` создает архив с gzip сжатием
  - Вся директория добавляется как одно целое
- **Ошибки**: `FileNotFoundError`, `NotADirectoryError`, общие исключения

##### `untar(path_archive_tar_gz, res)` → `None`
- **Параметры**: `path_archive_tar_gz` - путь к архиву, `res` - папка назначения (None = текущая директория)
- **Алгоритм**:
  1. Определение папки назначения (текущая директория или `res`)
  2. Проверка существования архива
  3. Создание директории назначения
  4. Открытие TAR.GZ архива в режиме `"r:gz"` (чтение с gzip распаковкой)
  5. Распаковка всех файлов через `tf.extractall(dst_dir)`
- **Нюансы**: Аналогично `unzip`, но для TAR.GZ формата
- **Ошибки**: `FileNotFoundError`, общие исключения

##### `grep(pattern, path, r, ignore_case)` → `list[str]`
- **Параметры**: `pattern` - регулярное выражение, `path` - файл/каталог, `r` - рекурсивный поиск, `ignore_case` - игнорирование регистра
- **Алгоритм**:
  1. Компиляция регулярного выражения с флагами (`re.IGNORECASE` если нужно)
  2. Определение списка файлов:
     - Если `path` - файл: добавляется в список
     - Если директория: обход через `rglob('*')` (рекурсивно) или `glob('*')` (не рекурсивно)
  3. Для каждого файла:
     - Открытие в режиме текста с кодировкой UTF-8 и обработкой ошибок `errors='ignore'`
     - Построчное чтение и поиск совпадений через `rgx.search(line)`
     - Добавление в результат строк формата `"{file_path}:{line_number}:{line.strip()}"`
  4. Обработка ошибок чтения отдельных файлов (продолжается поиск в остальных)
- **Нюансы**:
  - Используется `re.compile()` для оптимизации регулярного выражения
  - Ошибки чтения отдельных файлов не останавливают весь процесс
  - Результат - список строк с указанием файла, номера строки и содержимого
- **Ошибки**: `re.error` при некорректном регулярном выражении, ошибки чтения файлов логируются

---

### `main.py`

**Назначение**: Точка входа в приложение, CLI интерфейс через Typer.

#### `get_container(ctx)` → `Container`
- **Параметры**: `ctx` - контекст Typer
- **Назначение**: Получение контейнера зависимостей из контекста
- **Проверка**: Убеждается, что контейнер инициализирован (является экземпляром `Container`)
- **Ошибки**: `RuntimeError` если контейнер не инициализирован

#### `main(ctx)` → `None`
- **Параметры**: `ctx` - контекст Typer
- **Назначение**: Callback функция, выполняемая перед каждой командой
- **Алгоритм**:
  1. Настройка логирования через `logging.config.dictConfig(LOGGING_CONFIG)`
  2. Создание логгера для модуля
  3. Создание и сохранение контейнера с `WindowsConsoleService` в контексте
- **Нюансы**: Вызывается автоматически Typer перед каждой командой

#### Команды CLI

Все команды следуют общей структуре:
1. Получение контейнера через `get_container(ctx)`
2. Вызов соответствующего метода сервиса
3. Обработка результатов и ошибок
4. Вывод в консоль

##### `ls(ctx, path, detailed)` → `None`
- **Параметры**: `path` - путь к директории, `detailed` - флаг подробного режима
- **Алгоритм**: Преобразование флага в `FileDisplayMode`, вызов `ls()`, вывод через `sys.stdout.writelines()`
- **Ошибки**: `OSError` обрабатывается через `typer.echo()`

##### `cat(ctx, path, mode)` → `None`
- **Параметры**: `path` - путь к файлу, `mode` - флаг бинарного режима
- **Алгоритм**: Преобразование флага в `FileReadMode`, вызов `cat()`, вывод в зависимости от типа (байты через `sys.stdout.buffer.write()`, текст через `typer.echo()`)
- **Нюансы**: Раздельная обработка текстового и бинарного вывода
- **Ошибки**: `OSError` обрабатывается через `typer.echo()`

##### `cd(ctx, path)` → `None`
- **Параметры**: `path` - путь к директории (строка)
- **Алгоритм**: Вызов `cd()`, вывод нового пути через `sys.stdout.write()`
- **Ошибки**: `OSError` обрабатывается через `typer.echo()`

##### `cp(ctx, path1, path2, r)` → `None`
- **Параметры**: `path1` - источник, `path2` - назначение, `r` - флаг рекурсивного копирования
- **Алгоритм**: Прямой вызов `cp()` с передачей флага `recursive`
- **Ошибки**: `OSError` обрабатывается через `typer.echo()`

##### `mv(ctx, path1, path2)` → `None`
- **Параметры**: `path1` - источник, `path2` - назначение
- **Алгоритм**: Прямой вызов `mv()`
- **Ошибки**: `OSError` обрабатывается через `typer.echo()`

##### `rm(ctx, path, r)` → `None`
- **Параметры**: `path` - путь к удаляемому объекту, `r` - флаг рекурсивного удаления
- **Алгоритм**:
  1. Дополнительная проверка: если директория без флага `r`, вывод ошибки и выход
  2. Если директория с флагом `r`, запрос подтверждения через `typer.prompt()`
  3. Проверка существования пути
  4. Вызов `rm()`
- **Нюансы**:
  - Дополнительная валидация на уровне CLI (повторяет проверку сервиса)
  - Интерактивное подтверждение для рекурсивного удаления директорий
- **Ошибки**: `OSError` обрабатывается через `typer.echo()`

##### `zip(ctx, path, path_arch)` → `None`
- **Параметры**: `path` - каталог для упаковки, `path_arch` - путь к архиву
- **Алгоритм**: Вызов `zip()`, вывод сообщения об успехе через `typer.echo()`
- **Ошибки**: `OSError` обрабатывается через `typer.echo()`

##### `unzip(ctx, path_arch, res)` → `None`
- **Параметры**: `path_arch` - путь к архиву, `res` - папка назначения (опционально)
- **Алгоритм**: Вызов `unzip()`, вывод сообщения с путем распаковки через `typer.echo()`
- **Ошибки**: `OSError` обрабатывается через `typer.echo()`

##### `tar(ctx, path, path_arch)` → `None`
- **Параметры**: `path` - каталог для упаковки, `path_arch` - путь к архиву
- **Алгоритм**: Вызов `tar_dir()`, вывод сообщения об успехе
- **Ошибки**: `OSError` обрабатывается через `typer.echo()`

##### `untar(ctx, path_arch, res)` → `None`
- **Параметры**: `path_arch` - путь к архиву, `res` - папка назначения (опционально)
- **Алгоритм**: Вызов `untar()`, вывод сообщения с путем распаковки
- **Ошибки**: `OSError` обрабатывается через `typer.echo()`

##### `grep(ctx, pattern, path, r, ignore_case)` → `None`
- **Параметры**: `pattern` - регулярное выражение, `path` - файл/каталог, `r` - рекурсивный поиск, `ignore_case` - игнорирование регистра
- **Алгоритм**: Вызов `grep()`, вывод каждой строки результата через `typer.echo()`
- **Ошибки**: Все исключения обрабатываются через `typer.echo()` (включая `re.error`)

**Нюансы CLI**:
- Все команды используют единообразную обработку ошибок `OSError`
- Некоторые команды имеют дополнительную валидацию перед вызовом сервиса
- Результаты команд выводятся по-разному в зависимости от типа данных

---

## Проблемы и нюансы реализации

### Проблемы

1. **Дублирование валидации**:
   - В `main.py:rm()` есть проверка директории без флага `r`, которая дублирует проверку в `windows_console.py:rm()`
   - Можно было бы убрать дублирование и полагаться только на сервис

2. **Обработка ошибок в `grep`**:
   - Ошибки чтения отдельных файлов обрабатываются молча (только логирование)
   - Пользователь не уведомляется о проблемах с конкретными файлами

3. **Обработка путей в `cp`**:
   - При копировании директории в существующую директорию содержимое копируется, но логика немного запутанная
   - Если `final_dst` существует и является директорией, происходит копирование содержимого через цикл, что может быть медленнее

### Нюансы реализации

1. **Логирование**:
   - Все операции подробно логируются на разных уровнях (DEBUG, INFO, ERROR)
   - Логи сохраняются в файл с ротацией, что удобно для отладки

2. **Обработка путей**:
   - Использование `pathlib.Path` обеспечивает кроссплатформенную работу с путями
   - Автоматическое разрешение относительных путей и обработка специальных символов (`~`, `.`, `..`)

3. **Архивирование**:
   - При создании ZIP-архива пропускаются директории, добавляются только файлы (структура сохраняется через `arcname`)
   - При создании TAR.GZ архива директория добавляется целиком, что может дать разный результат

4. **Безопасность**:
   - В `rm()` есть защита от удаления корня и `..`, что предотвращает случайное удаление важных директорий

5. **Интерактивность**:
   - Команда `rm` запрашивает подтверждение при рекурсивном удалении директорий, что повышает безопасность

6. **Типизация**:
   - Использование типов `PathLike[str] | str` обеспечивает гибкость в передаче путей
   - Возвращаемые типы четко определены для всех методов
